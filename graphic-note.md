### 🧩图形管线中 GPU 自动执行的 **Early-Z（早期深度测试）** 与 **Late-Z（晚期深度测试）**，这确实是一次“隐式的两次深度测试”，在现代 GPU 中非常重要，下面我详细为你讲清楚：

------

## 🎯 早期深度测试（Early-Z） vs 晚期深度测试（Late-Z）

它们都是 GPU 中深度测试阶段的一部分，但**执行时机和作用不同**：

| 阶段        | 时机                | 优点                                 | 是否更新深度缓冲区 | 是否受 Shader 影响         |
| ----------- | ------------------- | ------------------------------------ | ------------------ | -------------------------- |
| **Early-Z** | 片元着色器 **之前** | 可以**提前剔除不可见像素**，节省计算 | 否                 | 会被禁用（如使用 discard） |
| **Late-Z**  | 片元着色器 **之后** | 保证最终写入深度值正确               | 是                 | 不受 Shader 行为影响       |



------

## 🔄 为什么 GPU 可能会执行“深度测试两次”？

因为现代 GPU 在片元着色器之前尝试**提前执行一次深度测试（Early-Z）**，但如果某些条件触发，它可能会在 **片元着色器之后再做一次（Late-Z）** 来修正最终写入。

------

## ✅ Early-Z 能工作的前提条件

只有在下面这些条件都满足时，Early-Z 才会开启：

- ✅ 没有用 `discard`（GLSL） 或 `clip()`（HLSL）
- ✅ 没有开启 `alpha blending`（透明混合）
- ✅ 片元着色器 **不会修改深度值**（例如 `gl_FragDepth`）
- ✅ 没有延迟写入目标（如 MRT 混合目标）
- ✅ 没有启用 stencil 操作依赖

------

## ❌ 什么会导致 Early-Z 被禁用？

- 使用了透明度混合（alpha blending）
- 使用 `discard;` 语句
- 修改了 `gl_FragDepth`
- 使用了模板测试（stencil test）
- 多渲染目标 + 某些 blend 模式
- 使用 `alpha-to-coverage`（多重采样抗锯齿）

------

## 🎯 为什么还要 Late-Z？

Late-Z 是为了确保“**即使 Early-Z 失败或跳过，仍能正确更新深度缓冲**”。

例如：

- 你在 shader 中用 `discard` 丢弃了某些片元
- 或你动态修改了 `gl_FragDepth`

> 这类操作让 GPU **必须等 shader 执行完**，才能知道最终该不该保留像素。

这时就 **不能在 shader 前提前做深度测试了**，所以要走 **Late-Z Pass**。

------

## 🔍 深度测试两次 ≠ 代价翻倍？

不完全等于。

- 如果 Early-Z 能丢掉很多像素，**节省了大量 shader 运算**。
- 如果 Early-Z 被禁用，**只能走 Late-Z，相当于损失 Early-Z 提前剔除的优势**。
- 若条件允许，GPU 甚至可能做 **Early-Z + Late-Z** 来实现保守剔除 + 最终确认。

------

## 🔧 实践建议（以 Vulkan/OpenGL 为例）

如果你想让 Early-Z 生效，确保以下设置：

```
glsl复制编辑// 不使用 discard
// 不写 gl_FragDepth
// 不开启透明混合（Alpha Blending）
// 启用深度测试并写入
layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(1.0); // 固定输出颜色
}
```

在 Vulkan 中：

```
cpp复制编辑VkPipelineDepthStencilStateCreateInfo.depthTestEnable = VK_TRUE;
VkPipelineDepthStencilStateCreateInfo.depthWriteEnable = VK_TRUE;
```

------

## 🧠 总结一下

| 阶段        | 执行时间    | 目的                   | 是否能省 Shader 计算 | 何时发生              |
| ----------- | ----------- | ---------------------- | -------------------- | --------------------- |
| **Early-Z** | Shader 之前 | 早期丢弃不可见片元     | ✅ 是                 | 如果满足条件          |
| **Late-Z**  | Shader 之后 | 确保最终深度值正确更新 | ❌ 否                 | 当 Early-Z 无法使用时 |



------

## 📊 补充图（建议在实际图形管线文档中参考）：

```
txt复制编辑顶点着色器
      ↓
装配/光栅化
      ↓
[Early Z Test] ←（如果 shader 用 discard，这步被跳过）
      ↓
片元着色器执行
      ↓
[Late Z Test] ←（最终决定是否更新深度缓冲）
      ↓
写入颜色、深度
```













### 🧩`discard` 语句是图形着色器语言（如 GLSL 或 HLSL）中的一个控制语句，**用于在片元着色器中丢弃当前片元（pixel）**，使其**不会写入颜色缓冲或深度缓冲**。

------

## 🧾 基本语法（GLSL）

```
glsl复制编辑if (some_condition)
    discard;
```

------

## 🧠 作用

### ✅ 丢弃像素，不输出颜色和深度

- 一旦执行 `discard;`，当前片元被直接抛弃；
- 不执行后续写入颜色或深度缓冲区；
- 当前像素完全“透明”或“空白”处理。

------

## 🔧 常见用途

### 1. **实现纹理透明区域剔除（Alpha Test）**

用于只显示不透明部分：

```
glsl复制编辑vec4 tex = texture(myTexture, UV);
if (tex.a < 0.1)
    discard;
```

等效于早期 OpenGL 中的 `alpha test`，用于剔除透明部分（例如树叶、铁丝网、衣服边缘）。

------

### 2. **可交互遮挡（遮罩）**

例如你做一个手电筒或圆形视野效果：

```
glsl复制编辑if (distance(UV, vec2(0.5)) > 0.5)
    discard;
```

只渲染圆内区域，其它区域都不绘制。

------

### 3. **复杂形状遮罩**

结合纹理和逻辑决定哪些像素渲染：

```
glsl复制编辑if (noise(UV) < 0.2)
    discard;
```

------

## 🚫 使用 `discard` 的注意事项

| 问题点                   | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ❌ 失去 Early-Z 优化      | GPU 无法提前判断是否丢弃，只能等 Shader 执行完再决定，Early-Z 被禁用，性能下降。 |
| ❌ 会引发透明排序问题     | `discard` 让很多像素只部分可见，需要你自己排序来正确叠加半透明物体。 |
| ❌ 不适合用于抗锯齿边缘   | 由于 `discard` 是硬性丢弃像素，不会插值边缘，可能出现锯齿。  |
| ❌ 难以配合 MSAA 多重采样 | `discard` 无法精细控制每个采样点的透明度。                   |



------

## 📌 小技巧

如果你在 Vulkan 或 OpenGL 中想要启用 `discard` 且又想保留性能，可以考虑：

- 把透明对象分离成独立渲染队列（后处理）；
- 考虑用 Alpha-to-Coverage（抗锯齿透明）；
- 对大面积 discard 区域使用几何裁剪（clip plane）。

------

## ✅ 总结一句话：

> `discard` 是你用来**主动丢弃当前像素**的指令，适合用来做“透明遮罩”、“剪裁区域”、“图案遮挡”等效果，但会禁用 Early-Z，可能带来性能和渲染顺序问题。